import React, { createContext, useContext, useEffect, useRef, useState, useCallback, ReactNode } from 'react';
import { io, Socket } from 'socket.io-client';
import { config } from '../config';

/**
 * @interface KlineData
 * @description KÁ∫øÊï∞ÊçÆÊé•Âè£
 */
interface KlineData {
  time: number;
  open: number;
  high: number;
  low: number;
  close: number;
}

/**
 * @interface SubscriptionConfig
 * @description ËÆ¢ÈòÖÈÖçÁΩÆÊé•Âè£
 */
interface SubscriptionConfig {
  symbol: string;
  interval: string;
  subscription_id?: string;
}

/**
 * @interface WebSocketContextValue
 * @description WebSocket‰∏ä‰∏ãÊñáÂÄºÊé•Âè£
 */
interface WebSocketContextValue {
  connectionStatus: 'connected' | 'disconnected' | 'error' | 'failed';
  _connectionStatus?: 'connected' | 'disconnected' | 'error' | 'failed';
  klineData: KlineData[];
  currentPrice: number | null;
  socket: Socket | null;
  subscribe: (config: SubscriptionConfig) => void;
  unsubscribe: (symbol: string, interval: string) => void;
  getHistoryData: (symbol: string, interval: string, limit?: number) => void;
  clearData: () => void;
  disconnect: () => void;
}

/**
 * @interface WebSocketProviderProps
 * @description WebSocketProviderÁªÑ‰ª∂Â±ûÊÄß
 */
interface WebSocketProviderProps {
  children: ReactNode;
}

const WebSocketContext = createContext<WebSocketContextValue | undefined>(undefined);

/**
 * @hook useWebSocket
 * @description ‰ΩøÁî®WebSocket‰∏ä‰∏ãÊñáÁöÑHook
 * @returns {WebSocketContextValue} WebSocket‰∏ä‰∏ãÊñáÂÄº
 * @throws {Error} ÂΩìÂú®WebSocketProviderÂ§ñÈÉ®‰ΩøÁî®Êó∂ÊäõÂá∫ÈîôËØØ
 */
export const useWebSocket = (): WebSocketContextValue => {
  const context = useContext(WebSocketContext);
  if (!context) {
    throw new Error('useWebSocket must be used within a WebSocketProvider');
  }
  return context;
};

/**
 * @component WebSocketProvider
 * @description WebSocketÊèê‰æõËÄÖÁªÑ‰ª∂
 * @param {WebSocketProviderProps} props - ÁªÑ‰ª∂Â±ûÊÄß
 * @returns {JSX.Element} WebSocketProviderÁªÑ‰ª∂
 */
export const WebSocketProvider: React.FC<WebSocketProviderProps> = ({ children }) => {
  const socketRef = useRef<Socket | null>(null);
  const [connectionStatus, setConnectionStatus] = useState<'connected' | 'disconnected' | 'error' | 'failed'>('disconnected');
  const [klineData, setKlineData] = useState<KlineData[]>([]);
  const [currentPrice, setCurrentPrice] = useState<number | null>(null);
  const subscriptionsRef = useRef<Map<string, SubscriptionConfig>>(new Map()); // Ë∑üË∏™ÊâÄÊúâËÆ¢ÈòÖ

  // WebSocketËøûÊé•ÁÆ°ÁêÜ
  const connectSocket = useCallback((): Socket => {
    // Â¶ÇÊûúÂ∑≤ÁªèÊúâsocketÂÆû‰æãÔºàÊó†ËÆ∫ÊòØÂê¶ËøûÊé•ÔºâÔºåÁõ¥Êé•ËøîÂõû
    if (socketRef.current) {
      console.log('üîó Â§çÁî®Áé∞ÊúâSocketËøûÊé•, Áä∂ÊÄÅ:', socketRef.current.connected ? 'Â∑≤ËøûÊé•' : 'ËøûÊé•‰∏≠');
      return socketRef.current;
    }

    const WEBSOCKET_URL: string = config.tradeQuoteWs || 'https://devtestapi.pinpet.fun';
    const WS_BASE_URL: string = WEBSOCKET_URL.endsWith('/kline') ? WEBSOCKET_URL.replace('/kline', '') : WEBSOCKET_URL;
    const NAMESPACE: string = '/kline';

    console.log('üîå ÂàõÂª∫Êñ∞ÁöÑ WebSocket ËøûÊé•:', `${WS_BASE_URL}${NAMESPACE}`);

    const socket: Socket = io(`${WS_BASE_URL}${NAMESPACE}`, {
      transports: ['websocket', 'polling'],
      timeout: 20000,
      reconnection: true,
      reconnectionAttempts: 5,
      reconnectionDelay: 1000,
      // ÂÖ∂‰ªñËøûÊé•ÈÖçÁΩÆ
      forceNew: false,           // Â§çÁî®ËøûÊé•
      multiplex: true,           // ÂÖÅËÆ∏Â§öË∑ØÂ§çÁî®
    });

    // ËøûÊé•‰∫ã‰ª∂
    socket.on('connect', () => {
      console.log('‚úÖ WebSocket Â∑≤ËøûÊé•, Socket ID:', socket.id);
      setConnectionStatus('connected');

      // ÈáçÊñ∞ËÆ¢ÈòÖÊâÄÊúâÁé∞ÊúâÁöÑËÆ¢ÈòÖ
      for (const [_key, subscription] of subscriptionsRef.current) {
        console.log('üîÑ ÈáçÊñ∞ËÆ¢ÈòÖ:', subscription);
        socket.emit('subscribe', subscription);
      }

      // ÂºÄÂßãÂøÉË∑≥ÊµãËØï
      console.log('‚úÖ ËøûÊé•ÊàêÂäüÔºåÂºÄÂßãÂøÉË∑≥ÊµãËØï');
      // ÊØè30ÁßíÊâãÂä®ÂèëÈÄÅ‰∏ÄÊ¨°pingÊù•ÊµãËØï
      const heartbeatInterval = setInterval(() => {
        if (socket.connected) {
          console.log('üì§ ÊâãÂä®ÂèëÈÄÅÂøÉË∑≥ÂåÖ');
          socket.emit('ping');
        } else {
          clearInterval(heartbeatInterval);
        }
      }, 30000);

      // Â≠òÂÇ®interval‰ª•‰æøÊ∏ÖÁêÜ
      (socket as any).heartbeatInterval = heartbeatInterval;
    });

    socket.on('disconnect', (reason: string) => {
      console.log('‚ùå WebSocket Êñ≠ÂºÄËøûÊé•:', reason);
      setConnectionStatus('disconnected');

      // Ê∏ÖÁêÜÂøÉË∑≥Èó¥Èöî
      if ((socket as any).heartbeatInterval) {
        clearInterval((socket as any).heartbeatInterval);
        (socket as any).heartbeatInterval = null;
      }
    });

    socket.on('connect_error', (error: Error) => {
      console.log('üí• ËøûÊé•ÈîôËØØ:', error.message);
      setConnectionStatus('error');
    });

    // Êï∞ÊçÆ‰∫ã‰ª∂
    socket.on('connection_success', (data: any) => {
      console.log('üéâ ËøûÊé•ÊàêÂäü:', data);
    });

    socket.on('subscription_confirmed', (data: any) => {
      console.log('‚úÖ ËÆ¢ÈòÖÁ°ÆËÆ§:', data);
    });

    socket.on('history_data', (data: any) => {
      console.log('üìà Êî∂Âà∞ÂéÜÂè≤Êï∞ÊçÆ:', {
        symbol: data.symbol,
        interval: data.interval,
        dataPoints: data.data?.length
      });

      if (data.data && data.data.length > 0) {
        const sortedData = data.data.sort((a: any, b: any) => a.time - b.time);

        const formattedData: KlineData[] = sortedData.map((item: any) => ({
          time: item.time,
          open: parseFloat(item.open),
          high: parseFloat(item.high),
          low: parseFloat(item.low),
          close: parseFloat(item.close)
        }));

        setKlineData(formattedData);
        setCurrentPrice(formattedData[formattedData.length - 1]?.close || null);
      }
    });

    socket.on('kline_data', (data: any) => {
      if (data.data) {
        console.log('üîî Êî∂Âà∞ÂÆûÊó∂KÁ∫øÊï∞ÊçÆ:', {
          symbol: data.symbol,
          interval: data.interval,
          time: new Date(data.data.time * 1000).toISOString()
        });

        const newCandle: KlineData = {
          time: data.data.time,
          open: parseFloat(data.data.open),
          high: parseFloat(data.data.high),
          low: parseFloat(data.data.low),
          close: parseFloat(data.data.close)
        };

        setCurrentPrice(newCandle.close);

        setKlineData(prevData => {
          const updatedData = [...prevData];
          const lastIndex = updatedData.length - 1;

          if (lastIndex >= 0 && updatedData[lastIndex].time === newCandle.time) {
            updatedData[lastIndex] = newCandle;
          } else {
            updatedData.push(newCandle);
          }

          return updatedData;
        });

        // Ëß¶ÂèëËá™ÂÆö‰πâ‰∫ã‰ª∂ÔºåÈÄöÁü•ÂÖ∂‰ªñÁªÑ‰ª∂ÊúâÊñ∞Êï∞ÊçÆ
        window.dispatchEvent(new CustomEvent('kline_update', {
          detail: { newCandle, symbol: data.symbol, interval: data.interval }
        }));
      }
    });

    socket.on('error', (error: any) => {
      console.log('‚ùå WebSocket ÈîôËØØ:', error);
    });

    // ÂøÉË∑≥ÂåÖÁõëÂê¨ (Áî®‰∫éË∞ÉËØï)
    socket.on('ping', () => {
      console.log('üíì Êî∂Âà∞ÊúçÂä°Âô® ping');
    });

    socket.on('pong', (ms: number) => {
      console.log('üíó Êî∂Âà∞ÊúçÂä°Âô® pong, Âª∂Ëøü:', ms, 'ms');
    });

    // Socket.IO ÂºïÊìéÁ∫ßÂà´ÁöÑÂøÉË∑≥ÂåÖ‰∫ã‰ª∂
    socket.io.engine.on('ping', () => {
      console.log('üíì ÂºïÊìéÁ∫ßÂà´ ping');
    });

    socket.io.engine.on('pong', () => {
      console.log('üíó ÂºïÊìéÁ∫ßÂà´ pong');
    });

    // ÁõëÂê¨ÂéÜÂè≤‰∫ã‰ª∂Êï∞ÊçÆ
    socket.on('history_event_data', (data: any) => {
      console.log('üìà Êî∂Âà∞ÂéÜÂè≤‰∫ã‰ª∂Êï∞ÊçÆ:', {
        symbol: data.symbol,
        eventCount: data.data?.length,
        hasMore: data.has_more,
        totalCount: data.total_count
      });

      if (data.data && data.data.length > 0) {
        // Ëß¶ÂèëËá™ÂÆö‰πâ‰∫ã‰ª∂Ôºå‰º†ÈÄíÂéÜÂè≤‰∫ã‰ª∂Êï∞ÊçÆ
        window.dispatchEvent(new CustomEvent('history_events_update', {
          detail: {
            symbol: data.symbol,
            events: data.data,
            hasMore: data.has_more,
            totalCount: data.total_count
          }
        }));
      }
    });

    // ÁõëÂê¨ÂÆûÊó∂‰∫ã‰ª∂Êï∞ÊçÆ
    socket.on('event_data', (data: any) => {
      console.log('üîî Êî∂Âà∞ÂÆûÊó∂‰∫ã‰ª∂Êï∞ÊçÆ:', {
        symbol: data.symbol,
        eventType: data.event_type,
        timestamp: new Date(data.timestamp).toISOString()
      });

      // Ëß¶ÂèëËá™ÂÆö‰πâ‰∫ã‰ª∂Ôºå‰º†ÈÄíÂÆûÊó∂‰∫ã‰ª∂Êï∞ÊçÆ
      window.dispatchEvent(new CustomEvent('event_update', {
        detail: {
          symbol: data.symbol,
          eventType: data.event_type,
          eventData: data.event_data,
          timestamp: data.timestamp
        }
      }));
    });


    // ËøûÊé•Ë¥®ÈáèÁõëÂê¨
    socket.on('connect_error', (error: Error) => {
      console.log('üí• ËøûÊé•ÈîôËØØ:', error.message);
      setConnectionStatus('error');
    });

    socket.on('reconnect', (attemptNumber: number) => {
      console.log('üîÑ ÈáçËøûÊàêÂäü, Â∞ùËØïÊ¨°Êï∞:', attemptNumber);
    });

    socket.on('reconnect_attempt', (attemptNumber: number) => {
      console.log('üîÑ Â∞ùËØïÈáçËøû, Á¨¨', attemptNumber, 'Ê¨°');
    });

    socket.on('reconnect_error', (error: Error) => {
      console.log('üí• ÈáçËøûÂ§±Ë¥•:', error.message);
    });

    socket.on('reconnect_failed', () => {
      console.log('üí• ÈáçËøûÂ§±Ë¥•ÔºåÂ∑≤ËææÂà∞ÊúÄÂ§ßÈáçËØïÊ¨°Êï∞');
      setConnectionStatus('failed');
    });

    socketRef.current = socket;
    return socket;
  }, []);

  // ËÆ¢ÈòÖÊï∞ÊçÆ
  const subscribe = useCallback((subscriptionConfig: SubscriptionConfig): void => {
    const socket = connectSocket();
    const key = `${subscriptionConfig.symbol}_${subscriptionConfig.interval}`;

    if (!subscriptionsRef.current.has(key)) {
      subscriptionsRef.current.set(key, subscriptionConfig);

      if (socket.connected) {
        console.log('üì§ ËÆ¢ÈòÖÂÆûÊó∂Êï∞ÊçÆ:', subscriptionConfig);
        socket.emit('subscribe', subscriptionConfig);
      }
    }
  }, [connectSocket]);

  // ÂèñÊ∂àËÆ¢ÈòÖ
  const unsubscribe = useCallback((symbol: string, interval: string): void => {
    const key = `${symbol}_${interval}`;
    const subscription = subscriptionsRef.current.get(key);

    if (subscription && socketRef.current) {
      console.log('üì§ ÂèñÊ∂àËÆ¢ÈòÖ:', { symbol, interval });
      socketRef.current.emit('unsubscribe', { symbol, interval });
      subscriptionsRef.current.delete(key);
    }
  }, []);

  // Ëé∑ÂèñÂéÜÂè≤Êï∞ÊçÆ
  const getHistoryData = useCallback((symbol: string, interval: string, limit: number = 50): void => {
    const socket = connectSocket();

    if (socket.connected) {
      console.log('üì§ ËØ∑Ê±ÇÂéÜÂè≤Êï∞ÊçÆ:', { symbol, interval, limit });
      socket.emit('history', { symbol, interval, limit });
    }
  }, [connectSocket]);

  // Ê∏ÖÈô§Êï∞ÊçÆ
  const clearData = useCallback((): void => {
    setKlineData([]);
    setCurrentPrice(null);
  }, []);

  // Ê∏ÖÁêÜËøûÊé•
  const disconnect = useCallback((): void => {
    if (socketRef.current) {
      console.log('üëã Êñ≠ÂºÄ WebSocket ËøûÊé•');

      // ÂèñÊ∂àÊâÄÊúâËÆ¢ÈòÖ
      for (const [_key, subscription] of subscriptionsRef.current) {
        socketRef.current.emit('unsubscribe', {
          symbol: subscription.symbol,
          interval: subscription.interval
        });
      }

      subscriptionsRef.current.clear();
      socketRef.current.disconnect();
      socketRef.current = null;
      setConnectionStatus('disconnected');
    }
  }, []);

  useEffect(() => {
    return () => {
      disconnect();
    };
  }, [disconnect]);

  const contextValue: WebSocketContextValue = {
    // Áä∂ÊÄÅ
    connectionStatus,
    klineData,
    currentPrice,
    socket: socketRef.current,

    // ÊñπÊ≥ï
    subscribe,
    unsubscribe,
    getHistoryData,
    clearData,
    disconnect
  };

  return (
    <WebSocketContext.Provider value={contextValue}>
      {children}
    </WebSocketContext.Provider>
  );
};